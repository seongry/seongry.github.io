{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021/08-09-functional-ish-javascript/","result":{"data":{"site":{"siteMetadata":{"title":"코알 데브 로그","author":"SeongRyeong Kim"}},"markdownRemark":{"id":"bb8fd831-184d-50c3-9c86-1d385e068a56","excerpt":"원문 함수형 프로그래밍은 자바스크립트를 작성할 때 배우고 적용할 수 있는 훌륭한 학문입니다. 무상태의(stateless), 멱등성의(idempotent), 사이드 이펙트가 없는(side-effect free…","html":"<p><a href=\"https://bluepnume.medium.com/functional-ish-javascript-205c05d0ed08\">원문</a></p>\n<hr>\n<p>함수형 프로그래밍은 자바스크립트를 작성할 때 배우고 적용할 수 있는 훌륭한 학문입니다. 무상태의(stateless), 멱등성의(idempotent), 사이드 이펙트가 없는(side-effect free) 코드를 작성하면 실제로 많은 문제가 해결됩니다:</p>\n<ul>\n<li>테스트하기 쉬워짐</li>\n<li>디버깅하기 쉬워짐</li>\n<li>이슈를 재현하기 쉬워짐</li>\n</ul>\n<p>하지만 커뮤니티에서는 함수형 프로그래밍은 모아니면 도라는 인식이 커지고 있습니다. 흔히 이런 말들을 듣습니다:</p>\n<blockquote>\n<p>제 전체 코드베이스/앱은 스테이트풀(stateful)하고 사이드 이펙트로 가득해요. 근데 왜 굳이 함수형으로 만들어야 하나요?</p>\n</blockquote>\n<blockquote>\n<p>저는 펑터(functors)나 모나드(monads), 커링(currying)이 뭔지(<em>역주: 함수형 프로그래밍의 기초 개념들입니다.</em>) 배울 시간이 없어요. 언젠가 할거긴 한데, 그때가서 함수형 코드들을 짤 것 같아요.</p>\n</blockquote>\n<blockquote>\n<p>저는 클래스 기반이나 객체 지향 코드가 좋아요. 그래서 함수형 코드는 저랑 안 맞는거 같아요.</p>\n</blockquote>\n<p>하지만 함수형 프로그래밍은 모 아니면 도일 필요가 없습니다. 필자의 생각엔 좀 더 실용적이게 되는것이 좋을 것 같아요. 즉 말하자면, 다른 할일이 없으면 <strong>함수형-스러운(functional-ish)</strong> 코드를 작성해 보세요.</p>\n<p>이게 무슨 의미 일까요? 필자는 요점을 설명하기 위한 일련의 법칙들을 생각해냈습니다.</p>\n<h1>순수하지 못하더라도 예측가능하도록</h1>\n<p>함수는 사이드 이펙트가 없을 경우 기능적으로 “순수”하다고 합니다. 순수 함수는 일련의 입력을 받고, 해당 입력을 기반으로 정확하고 확실하게 출력을 제공합니다. 다른 이펙트가 없고, 직접 입력한 입력외에는 다른 상태를 사용하지 않고, 입력값을 수정하지 않으며, 주어진 입력에 대해 출력은 항상 동일합니다.</p>\n<p>가능한 순수함수를 작성하는 것이 좋습니다. 순수 함수는 테스트하기 쉽고, 문서화하기 쉽고, 리펙터링하기 쉽습니다.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7a5f349506b019015b6833eb5b77f24f/f4b77/functional-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 40.54054054054054%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABK0lEQVQY02P4CwZ//vz5////lSvXFixdtWzlhpUr1q9evWH1GhS0dt3Gt2/fAZUBFUN0MUConz9/AkU7OvscFdTjvc2N/Uzl1XXl5HXkFXXkFHXklXTlweS5cxeByn7//o1Fc0/fZDV5TWtLS10Lcw1dM01NM3UNE01tMyDS0DTV0jG/cOESTs1dPRNVFAzsTD1MdO1M9e30bKzNXZ219M11jS1NLRyBms+fx625u2eSnKyWhbGjs5mHq5mnra2rlYOrmZmjua2zrr4VSPMFvJoVlfV09C11dSz1da10tS00tcy0dSz0DW3UNUHux6e5q3uCqLiymoaxgrIeEAENUlTRByFlPSUVfWVVA+zOhkTV/fsPdu/Zf/Dg0QMHj4DQARQSKP7x4yfkqAIAtAQtDodYKCAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"pure-function\"\n        title=\"\"\n        src=\"/static/7a5f349506b019015b6833eb5b77f24f/fcda8/functional-1.png\"\n        srcset=\"/static/7a5f349506b019015b6833eb5b77f24f/12f09/functional-1.png 148w,\n/static/7a5f349506b019015b6833eb5b77f24f/e4a3f/functional-1.png 295w,\n/static/7a5f349506b019015b6833eb5b77f24f/fcda8/functional-1.png 590w,\n/static/7a5f349506b019015b6833eb5b77f24f/f4b77/functional-1.png 770w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>그런데 만약 당신의 함수가 순수 할 수 없다면(실제로 시간이 많이 걸려서) 첫번째로 당신이 해야할 일은 예측가능하게 만드는 것입니다:</p>\n<ul>\n<li>함수가 특정 사이드 이펙트를 트리거해야하는 경우, 동일한 입력이 주어질땐 해당 이펙트들이 항상 동일해야합니다. 서로 다른 입력이 서로 다른 사이드 이펙트를 트리거한다면, 그러한 이펙트들은 굉장히 예측 가능해야합니다.</li>\n<li>함수가 다른 스코프(클로저 스코프나, 모듈 스코프 혹은 글로벌 스코프처럼)의 데이터나 상태를 소비해야 하는 경우, 앱의 미래 상태를 기반으로 시간이 지남에 따라 상태가 변경되거나 완전히 존재하지 않도록 복원해야 합니다.</li>\n<li>함수는 전달된 파라메터가 객체나 배열같은 가변 데이터 구조일지라도 거의 변경하지 않아야 합니다. 이 규칙의 예외는 특정 목적을 가진 함수가 객체를 예측가능한 방식으로 변경하는 것일 겁니다; 사이드 이펙트가 명확한 <code class=\"language-text\">arrayRemove</code> 처럼요.</li>\n</ul>\n<p>여기에 의구심이 든다면, 당신이 작성하는 함수에 <a href=\"https://ko.wikipedia.org/wiki/%EB%86%80%EB%9E%8C_%EC%B5%9C%EC%86%8C%ED%99%94_%EC%9B%90%EC%B9%99\">놀람 최소화 원칙(Principle of Least Astonishment)</a>를 따르세요.</p>\n<h1>상태 사용에 보수적이 되어라</h1>\n<p>순수함수는 외부 상태에 의존하지 않습니다. 이는 변수나 데이터가 함수의 내부나 외부에서 바뀌고, 이를 함수가 의존한다면 그 함수는 순수하지 않다는 뜻입니다.</p>\n<p>현실에서, 코드에 어떤 종류든 상태를 사용하는 것은 피할 수 없습니다. 그렇긴해도 최소한 그 상태가 스테이트풀이 되어야 할지 신중히 고려할 수는 있습니다.</p>\n<ul>\n<li>필요한 데이터가 다른 입력이나 가지고있는 기존 상태를 기반으로 파생되어야 하나요? 만일 그렇다면, 상태로 저장하지 않는 것이 제일 좋습니다.</li>\n<li>데이터가 한번쓰이고 버려지는 데이터인가요? 만일 그렇다면, 그 데이터의 유용성보다 오래 지속될 상태나 스코프 안에 지속되게 하지 마세요.</li>\n<li>나중에 필요한 데이터, 혹은 앱의 생명주기(lifecycle) 내에서 점진적인 변경이 일어날 것이라 예상되는 데이터인가요? 드디어 당신은 데이터를 상태 안에 저장할 수 있는 좋은 이유가 있습니다.</li>\n</ul>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/055056b0fa4bf0b19f78d0d1ee3fbb04/0940f/functional-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 37.83783783783784%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAABS0lEQVQY02XRy07CQBSAYV7CmFKQq7TUOtMWSu1Mpy0XoaWKGrfqQqByEfACYaUvgYkJDwkb3EGwiUShJv9mkvNlcnICq9VqvV5/TqbjQW8wHj60n/9qPW0/W52Xhtsfjt4Wiy+PLJfLwA+u37rKEcPlxHCUP/AV2xSJHVM0K0jabDbfwU23n04qUkaHWBMxkQwdiEjO5gFELCenuZwXxyspNoNJZT7fxW5zABkFZQtQQpBggDDIYUHVgIz4jAIUFSqYh2riUFDxqR/XG71kQlClvGFWrcvron1RqNTyds20alrZKZxdmSVH0y0gIA/P/uNIHEARK2pRN6q64RBiZVFZNs9l3cniiigSotsnaokYtn/nmzt3bz8RjYNgiKXoFEUzVIihQ0yQ3kSH03SY9Wa8z/148jG9r3c73dft2rt1Hofe8Ubj999TfQPsO9U1M86IFAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"logUserIn\"\n        title=\"\"\n        src=\"/static/055056b0fa4bf0b19f78d0d1ee3fbb04/fcda8/functional-2.png\"\n        srcset=\"/static/055056b0fa4bf0b19f78d0d1ee3fbb04/12f09/functional-2.png 148w,\n/static/055056b0fa4bf0b19f78d0d1ee3fbb04/e4a3f/functional-2.png 295w,\n/static/055056b0fa4bf0b19f78d0d1ee3fbb04/fcda8/functional-2.png 590w,\n/static/055056b0fa4bf0b19f78d0d1ee3fbb04/efc66/functional-2.png 885w,\n/static/055056b0fa4bf0b19f78d0d1ee3fbb04/0940f/functional-2.png 1154w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h1>스코프를 유리하게 사용하라</h1>\n<p>일단 당신이 실제로 상태가 <em>필요하다고</em> 정했다고해도, 아직 모든 계산이 끝난게 아닙니다. 어떤 상태는 함수 호출 기간보다 더 오래 존재해야하지만, 그래도 여전히 그 상태가 얼마나 오래 존재해야 하는지는 신중히 고려해야합니다.</p>\n<p>다양한 스코프를 활용해서 상태를 필요한 만큼만 유지할 수 있도록 할 수 있습니다:</p>\n<ul>\n<li>현재 로직에만 필요하다면, <code class=\"language-text\">const</code> 나 <code class=\"language-text\">let</code>을 사용해서 현재의 블록 스코프에 저장하세요.</li>\n<li>함수가 호출되는 전체 기간 동안 필요하다면, 함수 내부의 맨 위쪽단에 <code class=\"language-text\">const</code> 나 <code class=\"language-text\">let</code> 변수로 선언해서 그 안에 저장하세요.</li>\n<li>만약 더 오래 존재해야 한다면 - 비동기 함수 호출이 끝날때까지 - 클로저 스코프 안에 저장하세요.</li>\n<li>리엑트를 사용한다면 상태를 실제로 필요한 컴포넌트에 최대한 가깝게 두고, 컴포넌트 체인에 너무 높게 끌어올리지(hoist) 마세요.</li>\n<li>여러 함수 호출에 걸쳐 뭔가 추적해야 할 경우 부모 함수의 스코프 안에 유지하거나, 혹은 모듈 스코프에 저장할 수도 있습니다.</li>\n<li>상태가 여러 페이지에 걸쳐 유지되야한다면 임시로 서버 스토어나(세션처럼) 로컬스토리지에 저장 합니다.</li>\n</ul>","frontmatter":{"title":"Functional-ish JavaScript","date":"August 09, 2021","tags":["javascript","번역"]}}},"pageContext":{"slug":"/2021/08-09-functional-ish-javascript/","previous":{"fields":{"slug":"/2021/07-01-use-console-log-like-a-pro/"},"frontmatter":{"title":"Use console.log() like a pro"}},"next":{"fields":{"slug":"/2021/12-05-try-to-use-msw-on-testing/"},"frontmatter":{"title":"테스트 환경에 MSW 도입"}}}}}